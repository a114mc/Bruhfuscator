package me.iris.ambien.obfuscator.transformers.implementations.exploits;

import me.iris.ambien.obfuscator.builders.ClassBuilder;
import me.iris.ambien.obfuscator.settings.data.implementations.BooleanSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.ListSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.NumberSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.StringSetting;
import me.iris.ambien.obfuscator.transformers.data.Category;
import me.iris.ambien.obfuscator.transformers.data.Ordinal;
import me.iris.ambien.obfuscator.transformers.data.Stability;
import me.iris.ambien.obfuscator.transformers.data.Transformer;
import me.iris.ambien.obfuscator.transformers.data.annotation.TransformerInfo;
import me.iris.ambien.obfuscator.utilities.GOTOASMUtils;
import me.iris.ambien.obfuscator.utilities.IOUtil;
import me.iris.ambien.obfuscator.utilities.StringUtil;
import me.iris.ambien.obfuscator.wrappers.ClassWrapper;
import me.iris.ambien.obfuscator.wrappers.JarWrapper;
import me.iris.ambien.obfuscator.wrappers.MethodWrapper;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;

/**
 * Crashes & confuses various decompilers & other reverse engineering tools
 */
@TransformerInfo(
        name = "crasher",
        category = Category.EXPLOITS,
        stability = Stability.STABLE,
        ordinal = Ordinal.LOW,
        description = "Adds code/classes that cause decompilers & re tools to fail to decompile the class/jar."
)
public class Crasher extends Transformer {
    private final Map<ClassWrapper, List<MethodWrapper>> classMethodsMap = new ConcurrentHashMap<>();
    private final String repeatType = StringUtil.repeat("[", 255);

    /**
     * Crashes swing based decompilers because of them trying to render the html
     */
    public final BooleanSetting hypertext = new BooleanSetting("hypertext", false);
    public final StringSetting hypertextLink = new StringSetting("hypertext-link", "ambien");
    public final ListSetting hypertextText = new ListSetting("hypertext-text", new ArrayList<>(Arrays.asList("")));

    /**
     * Adds long end-line character annotations to methods & fields
     * This causes decompilers to be very slow or not decompile at all
     */
    public final BooleanSetting badAnnotations = new BooleanSetting("bad-annotations", false);
    public final ListSetting badAnnotationsWords = new ListSetting("bad-annotations-words", new ArrayList<>(Arrays.asList("")));
    public final NumberSetting<Integer> badAnnotationsAmount = new NumberSetting<>("bad-annotations-amount", 100);

    /**
     * Adds a class that inherits itself, causing some tools to get stuck in an infinite loop of decompiling the class
     */
    public final BooleanSetting selfInheritance = new BooleanSetting("self-inheritance", false);
    public final StringSetting selfInheritanceName = new StringSetting("self-inheritance-name", "Main");
    public final ListSetting selfInheritanceText = new ListSetting("self-inheritance-text", new ArrayList<>(Arrays.asList("")));


    /**
     * Adds random text to null method & class signatures, most decompilers will crash or just ignore it
     */
    public static final BooleanSetting junkSignatures = new BooleanSetting("junk-signatures", false);
    public static final BooleanSetting decompilerCrasher = new BooleanSetting("decompiler-crasher", false);

    public static final BooleanSetting yeetJump = new BooleanSetting("funny-catch-jump", false);

    public static final BooleanSetting shitClasses = new BooleanSetting("shit-classes", false);
    public static final NumberSetting<Integer> shitAmount = new NumberSetting<>("shit-amount", 100);
    public static final NumberSetting<Integer> shitDepth = new NumberSetting<>("shit-depth", 100);
    public static final NumberSetting<Integer> shitMaxDepth = new NumberSetting<>("shit-max-depth", 500);

    @Override
    public void transform(JarWrapper wrapper) {
        if (yeetJump.isEnabled()) {
            for (ClassWrapper cn : wrapper.getClasses()) {
                for (MethodWrapper mw : cn.getTransformableMethods()) {
                    MethodNode mn = mw.getNode();

                    // 跳过构造函数，避免程序崩溃
                    if (mn.name.contains("<")) {
                        continue;
                    }

                    // 如果方法没有代码，跳过
                    if (GOTOASMUtils.isSpecialMethod(mn)) {
                        continue;
                    }

                    // 获取原始指令集的第一个指令，作为混淆代码的跳转目标
                    AbstractInsnNode originalStart = mn.instructions.getFirst();
                    LabelNode originalStartLabel = new LabelNode();
                    mn.instructions.insertBefore(originalStart, originalStartLabel);

                    // 创建所有必要的标签
                    LabelNode A = new LabelNode();
                    LabelNode B = new LabelNode();
                    LabelNode C = new LabelNode();
                    LabelNode D = new LabelNode(); // 真正的 catch block 入口
                    LabelNode E = new LabelNode(); // 假的 catch handler 入口
                    LabelNode F = new LabelNode();

                    // 创建一个新的指令列表，用于你的混淆字节码
                    InsnList obfuscationInstructions = new InsnList();

                    // 1. 注入 try 块开始
                    obfuscationInstructions.add(A);
                    obfuscationInstructions.add(new LdcInsnNode("Stop it!"));
                    obfuscationInstructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false));
                    obfuscationInstructions.add(new InsnNode(Opcodes.POP));

                    obfuscationInstructions.add(B);
                    obfuscationInstructions.add(new LdcInsnNode("Give up,"));
                    obfuscationInstructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false));
                    obfuscationInstructions.add(new InsnNode(Opcodes.POP));

                    obfuscationInstructions.add(C);
                    obfuscationInstructions.add(new LdcInsnNode("Right now!"));
                    obfuscationInstructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false));
                    obfuscationInstructions.add(new InsnNode(Opcodes.POP));
                    // 正常执行路径的末尾，跳转到原始代码
                    obfuscationInstructions.add(new JumpInsnNode(Opcodes.GOTO, originalStartLabel));

                    // 这里我们注入一个非正常跳转，它会从 try 块内跳到 catch handler
                    obfuscationInstructions.add(new TypeInsnNode(Opcodes.NEW, "java/lang/Exception"));
                    obfuscationInstructions.add(new InsnNode(Opcodes.DUP));
                    obfuscationInstructions.add(new MethodInsnNode(Opcodes.INVOKESPECIAL, "java/lang/Exception", "<init>", "()V", false));
                    obfuscationInstructions.add(new InsnNode(Opcodes.ATHROW));

                    // 2. 注入 catch 块的假的 handler
                    obfuscationInstructions.add(E);

                    // 这个假的 handler 会 astore 异常，然后跳转到真正的 catch block
                    int exceptionLocal = mn.maxLocals;
                    if ((mn.access & Opcodes.ACC_STATIC) == 0) {
                        exceptionLocal = mn.maxLocals;
                    }
                    obfuscationInstructions.add(new VarInsnNode(Opcodes.ASTORE, exceptionLocal));
                    obfuscationInstructions.add(new JumpInsnNode(Opcodes.GOTO, D));

                    // 3. 注入真正的 catch block
                    obfuscationInstructions.add(D);
                    obfuscationInstructions.add(new LdcInsnNode("fuck"));
                    obfuscationInstructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false));
                    obfuscationInstructions.add(new InsnNode(Opcodes.POP));

                    obfuscationInstructions.add(F);
                    // 在 catch 块的末尾，跳转回 try 块内的某个标签
                    obfuscationInstructions.add(new JumpInsnNode(Opcodes.GOTO, B));

                    // 将混淆代码插入到原始指令列表的头部
                    mn.instructions.insertBefore(originalStartLabel, obfuscationInstructions);

                    // 让ASM更新 maxLocals 和 maxStack
                    mn.maxLocals = 0;
                    mn.maxStack = 0;

                    // 创建并注入能够崩溃JetBrains decompiler的 TryCatchBlockNode
                    TryCatchBlockNode tcb = new TryCatchBlockNode(A, C, E, "java/lang/Throwable");
                    if (mn.tryCatchBlocks == null) {
                        mn.tryCatchBlocks = new ArrayList<>();
                    }
                    mn.tryCatchBlocks.add(tcb);
                }
            }
        }
        // Add incomplete hypertext
        if (hypertext.isEnabled())
            addSwingCrasherClass(wrapper);

        // Add a class that inherits itself
        if (selfInheritance.isEnabled())
            addSelfInheritanceClass(wrapper);

        if (decompilerCrasher.isEnabled())
            addDecompilerCrasher(wrapper);

        // Add crashers to classes
        getClasses(wrapper).stream()
            .filter(classWrapper -> {
                String className = classWrapper.getNode().name;
                return !(className.contains(hypertextLink.getValue()) || className.contains(selfInheritanceName.getValue()));
            })
            .forEach(classWrapper -> {
                if (badAnnotations.isEnabled()) {
                    List<String> words = new ArrayList<>();
                    badAnnotationsWords.getOptions().forEach(value -> {
                        if (value.endsWith(".txt")) {
                            words.addAll(StringUtil.readDictionaryFromFile(value));
                        } else words.add(value);
                    });
                    addBadAnnotations(classWrapper, words);
                }
                if (junkSignatures.isEnabled())
                    addJunkSignatures(classWrapper);
            }
        );
    }

    private void addDecompilerCrasher(final JarWrapper wrapper) {
        getClasses(wrapper)
                .forEach(classWrapper -> {
                    List<MethodWrapper> methods = classWrapper.getTransformableMethods().stream()
                            // !methodWrapper.hasInstructions() или methodWrapper.hasInstructions()
                            .filter(methodWrapper -> methodWrapper.hasInstructions() && !methodWrapper.isInitializer() && methodWrapper.getNode().instructions.getFirst() instanceof LabelNode)
                            .collect(Collectors.toList());
                    classMethodsMap.put(classWrapper, methods);
                });

        classMethodsMap.forEach((classWrapper, methods) ->
                methods.forEach(methodWrapper -> {
                    MethodNode method = methodWrapper.getNode();
                    InsnList list = new InsnList();
                    list.add(new LabelNode());
                    list.add(new InsnNode(ACONST_NULL));
                    list.add(new JumpInsnNode(IFNULL, (LabelNode) method.instructions.getFirst()));
                    list.add(new InsnNode(ACONST_NULL));
                    list.add(new TypeInsnNode(CHECKCAST,repeatType + "L;"));
                    list.add(new InvokeDynamicInsnNode(StringUtil.randomIllegalJavaName(),"(" + repeatType + "L;)V", new Handle(H_INVOKESTATIC, StringUtil.randomIllegalJavaName(), StringUtil.randomIllegalJavaName(),"()L;",false),""));
                    method.instructions.insertBefore(method.instructions.getFirst(),list);
                })
        );
    }

    public static void addShitClasses(String basePath, JarOutputStream stream) throws IOException {
        ClassNode node = new ClassNode();

        node.name = "<html><img src=\"https:" + StringUtil.randomString(10,"0123456789");
        node.access = ACC_PUBLIC;
        node.version = V1_8;

        ClassWriter writer = new ClassWriter(0);
        node.accept(writer);

        StringBuilder builder = new StringBuilder();

        if (basePath != null) {
            builder.append(basePath);
        }

        for (int i = 0; i < ThreadLocalRandom.current().nextInt(shitDepth.getValue(), shitMaxDepth.getValue()); i++) {
            builder.append("\n\u3000\u2007".charAt(ThreadLocalRandom.current().nextInt(0, 3))).append(File.separator);
        }

        builder.append(StringUtil.randomSpace()).append(".class");
        String s = builder.toString();

        IOUtil.writeEntry(stream, s, writer.toByteArray());
    }

    private void addSwingCrasherClass(final JarWrapper wrapper) {
        final String name = "<html><img src=\"" + hypertextLink.getValue();
        final ClassBuilder builder = new ClassBuilder().setName(name).setAccess(ACC_PUBLIC).setVersion(V1_5);
        final ClassNode node = builder.buildNode();
        if (!hypertextText.getOptions().get(0).equals("")) {
            List<String> inputList = hypertextText.getOptions();
            String[][] messages = new String[inputList.size()][2];

            for (int i = 0; i < inputList.size(); i++) {
                String[] parts = inputList.get(i).split("\\s*\\|\\s*", -1);
                messages[i][0] = parts[0].trim(); // Текст до |
                messages[i][1] = parts[1].trim(); // Текст после |
            }

            for (String[] messageData : messages) {
                FieldNode fieldNode = new FieldNode(ACC_STATIC, messageData[1], "Ljava/lang/String;", null, null);
                node.fields.add(fieldNode);
            }

            MethodNode clinit = new MethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
            InsnList clinitInstructions = clinit.instructions;

            for (String[] messageData : messages) {
                clinitInstructions.add(new LdcInsnNode(messageData[0]));
                clinitInstructions.add(new FieldInsnNode(Opcodes.PUTSTATIC, name, messageData[1], "Ljava/lang/String;"));
            }

            clinitInstructions.add(new InsnNode(Opcodes.RETURN));
            node.methods.add(clinit);
        }

        wrapper.getClasses().add(new ClassWrapper(name + ".class", node, false));
    }

    private void addSelfInheritanceClass(final JarWrapper wrapper) {
        final String name = selfInheritanceName.getValue();
        final ClassBuilder builder = new ClassBuilder().setName(name).setSuperName(name).setAccess(ACC_PUBLIC);
        final ClassNode node = builder.buildNode();

        if (!selfInheritanceText.getOptions().get(0).equals("")) {
            List<String> inputList = selfInheritanceText.getOptions();
            String[][] messages = new String[inputList.size()][2];

            for (int i = 0; i < inputList.size(); i++) {
                String[] parts = inputList.get(i).split("\\s*\\|\\s*", -1);
                messages[i][0] = parts[0].trim(); // Текст до |
                messages[i][1] = parts[1].trim(); // Текст после |
            }

            for (String[] messageData : messages) {
                FieldNode fieldNode = new FieldNode(ACC_STATIC, messageData[1], "Ljava/lang/String;", null, null);
                node.fields.add(fieldNode);
            }

            MethodNode clinit = new MethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
            InsnList clinitInstructions = clinit.instructions;

            for (String[] messageData : messages) {
                clinitInstructions.add(new LdcInsnNode(messageData[0]));
                clinitInstructions.add(new FieldInsnNode(Opcodes.PUTSTATIC, name, messageData[1], "Ljava/lang/String;"));
            }

            clinitInstructions.add(new InsnNode(Opcodes.RETURN));
            node.methods.add(clinit);
        }

        wrapper.getClasses().add(new ClassWrapper(name + ".class", node, false));
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private void addBadAnnotations(final ClassWrapper wrapper, List<String> badAnnotationsWords) {
        // Construct the repeated string with words separated by '\n'
        StringBuilder repeatedEndLineBuilder = new StringBuilder();
        for (int i = 0; i < badAnnotationsAmount.getValue(); i++) {
            repeatedEndLineBuilder.append(badAnnotationsWords.get(i % badAnnotationsWords.size()));
            repeatedEndLineBuilder.append('\n');
        }
        final String repeatedEndLine = repeatedEndLineBuilder.toString();

        // Add invisible annotation to class
        if (wrapper.getNode().invisibleAnnotations == null)
            wrapper.getNode().invisibleAnnotations = new ArrayList();
        wrapper.getNode().invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));

        // Add invisible annotations to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.invisibleAnnotations == null)
                methodNode.invisibleAnnotations = new ArrayList();
            methodNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });

        // Add invisible annotations to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.invisibleAnnotations == null)
                fieldNode.invisibleAnnotations = new ArrayList();
            fieldNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });
    }

    private void addJunkSignatures(final ClassWrapper wrapper) {
        // Add junk signature to class
        wrapper.getNode().signature = StringUtil.genName(15);

        // Add junk signature to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.signature != null) return;
            methodNode.signature = StringUtil.genName(15);
        });

        // Add junk signature to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.signature != null) return;
            fieldNode.signature = StringUtil.genName(15);
        });
    }
}
